"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const coc_nvim_1 = require("coc.nvim");
const util_1 = require("../util");
const events_1 = require("events");
const readline_1 = tslib_1.__importDefault(require("readline"));
const path_1 = tslib_1.__importDefault(require("path"));
class CommitsTask extends events_1.EventEmitter {
    constructor(root, file) {
        super();
        this.root = root;
        this.file = file;
    }
    start(cmd, args, cwd) {
        this.process = child_process_1.spawn(cmd, args, { cwd });
        this.process.on('error', e => {
            this.emit('error', e.message);
        });
        this.process.stderr.on('data', chunk => {
            console.error(chunk.toString('utf8')); // tslint:disable-line
        });
        const rl = readline_1.default.createInterface(this.process.stdout);
        rl.on('line', line => {
            if (!line.length)
                return;
            let res = coc_nvim_1.ansiparse(line);
            let idx = res.findIndex(o => o.foreground == 'yellow');
            let message = idx == -1 ? null : res[idx + 1].text;
            let item = res.find(o => o.foreground == 'red' && o.text.length > 4);
            let commit = item ? item.text : '';
            this.emit('data', {
                label: line,
                data: {
                    commit,
                    file: this.file,
                    root: this.root,
                    message: message ? message.trim() : null
                }
            });
        });
        rl.on('close', () => {
            this.emit('end');
        });
    }
    dispose() {
        if (this.process) {
            this.process.kill();
        }
    }
}
class Bcommits extends coc_nvim_1.BasicList {
    constructor(nvim, manager) {
        super(nvim);
        this.manager = manager;
        this.name = 'bcommits';
        this.description = 'Commits of current file.';
        this.defaultAction = 'show';
        this.actions = [];
        this.addAction('preview', (item, context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let winid = context.listWindow.id;
            let mod = context.options.position == 'top' ? 'below' : 'above';
            let { commit, root } = item.data;
            if (!commit) {
                yield util_1.showEmptyPreview(mod, winid);
                return;
            }
            let content = yield util_1.runCommand(`git --no-pager show ${commit}`, { cwd: root });
            let lines = content.trim().split('\n');
            nvim.pauseNotification();
            nvim.command('pclose', true);
            nvim.command(`${mod} ${this.previewHeight}sp +setl\\ previewwindow [commit ${commit}]`, true);
            nvim.command('setl winfixheight buftype=nofile foldmethod=syntax', true);
            nvim.command('setl nobuflisted bufhidden=wipe', true);
            nvim.command('setf git', true);
            nvim.call('append', [0, lines], true);
            nvim.command('normal! Gdd', true);
            nvim.command(`exe 1`, true);
            nvim.call('win_gotoid', [winid], true);
            yield nvim.resumeNotification();
        }));
        this.addAction('show', (item) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { commit, root } = item.data;
            if (!commit)
                return;
            let hasFugitive = yield nvim.getVar('loaded_fugitive');
            if (hasFugitive) {
                yield nvim.command(`Gedit ${commit}`);
            }
            else {
                let content = yield util_1.runCommand(`git --no-pager show ${commit}`, { cwd: root });
                let lines = content.trim().split('\n');
                nvim.pauseNotification();
                nvim.command(`edit +setl\\ buftype=nofile [commit ${commit}]`, true);
                nvim.command('setl foldmethod=syntax nobuflisted bufhidden=wipe', true);
                nvim.command('setf git', true);
                nvim.call('append', [0, lines], true);
                nvim.command('normal! Gdd', true);
                nvim.command(`exe 1`, true);
                yield nvim.resumeNotification();
            }
        }));
        this.addAction('diff', (item, context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let buffer = yield context.window.buffer;
            let filetype = yield buffer.getOption('filetype');
            let { root, commit, file } = item.data;
            if (!commit)
                return;
            let content = yield util_1.runCommand(`git --no-pager show --no-color ${commit}:${file}`, { cwd: root });
            if (!content)
                return;
            let lines = content.replace(/\n$/, '').split(/\r?\n/);
            nvim.pauseNotification();
            nvim.command('diffoff', true);
            nvim.command('diffthis', true);
            nvim.command(`keepalt vsplit +setl\\ buftype=nofile [Git ${commit}]`, true);
            nvim.call('append', [0, lines], true);
            nvim.command('normal! Gdd', true);
            nvim.command(`exe 1`, true);
            nvim.command(`setf ${filetype}`, true);
            nvim.command('diffthis', true);
            nvim.command('setl foldenable', true);
            nvim.command(`call setwinvar(winnr(), 'easygit_diff_origin', ${buffer.id})`, true);
            nvim.command(`call setpos('.', [bufnr('%'), 0, 0, 0])`, true);
            yield nvim.resumeNotification();
        }));
        coc_nvim_1.events.on('BufEnter', (bufnr) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.bufnr || bufnr != this.bufnr)
                return;
            let diff = yield nvim.eval('&diff');
            if (!diff)
                return;
            let res = yield nvim.eval(`map(getwininfo(), 'get(v:val["variables"], "easygit_diff_origin", 0)')`);
            let idx = res.findIndex(i => i == bufnr);
            if (idx == -1)
                yield nvim.command('diffoff');
        }), null, this.disposables);
    }
    loadItems(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let buf = yield context.window.buffer;
            let root = yield this.manager.resolveGitRoot(buf.id);
            if (!root) {
                throw new Error(`Can't resolve git root.`);
                return;
            }
            let doc = coc_nvim_1.workspace.getDocument(buf.id);
            if (!doc || doc.schema != 'file') {
                throw new Error(`Current buffer is not file`);
                return;
            }
            let file = path_1.default.relative(root, coc_nvim_1.Uri.parse(doc.uri).fsPath);
            const output = yield util_1.runCommand(`git ls-files ${context.args.join(' ')} -- ${file}`);
            if (!output.trim()) {
                throw new Error(`${file} not indexed`);
                return;
            }
            this.bufnr = buf.id;
            const args = ['--no-pager', 'log', '--pretty', '--color',
                `--format=%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset`,
                '--abbrev-commit', '--date=iso', '--', file];
            let task = new CommitsTask(root, file);
            task.start('git', args, root);
            return task;
        });
    }
}
exports.default = Bcommits;
//# sourceMappingURL=bcommits.js.map