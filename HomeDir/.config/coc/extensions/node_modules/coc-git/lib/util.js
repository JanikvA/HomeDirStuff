"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const child_process_1 = require("child_process");
function safeRun(cmd, opts = {}) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            return yield runCommand(cmd, opts, 5000);
        }
        catch (e) {
            return null;
        }
    });
}
exports.safeRun = safeRun;
function showEmptyPreview(mod, winid) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let { nvim } = coc_nvim_1.workspace;
        nvim.pauseNotification();
        nvim.command('pclose', true);
        nvim.command(`${mod} 1new +setl\\ previewwindow`, true);
        nvim.command('setl winfixheight buftype=nofile foldmethod=syntax foldenable', true);
        nvim.command('setl nobuflisted bufhidden=wipe', true);
        nvim.command('setf git', true);
        nvim.call('win_gotoid', [winid], true);
        yield nvim.resumeNotification();
    });
}
exports.showEmptyPreview = showEmptyPreview;
function spawnCommand(cmd, args, cwd) {
    const cp = child_process_1.spawn(cmd, args, { cwd });
    let res = '';
    return new Promise((resolve, reject) => {
        cp.stdout.on('data', data => {
            res += data.toString();
        });
        cp.stderr.on('data', data => {
            coc_nvim_1.workspace.showMessage(`"${cmd} ${args.join(' ')}" error: ${data.toString()}`, 'error');
        });
        cp.on('close', code => {
            if (code != 0) {
                return reject(new Error(`${cmd} exited with code ${code}`));
            }
            resolve(res);
        });
    });
}
exports.spawnCommand = spawnCommand;
function runCommandWithData(cmd, args, cwd, data) {
    const cp = child_process_1.spawn(cmd, args, { cwd });
    cp.stdin.write(data, 'utf8');
    cp.stdin.end();
    let res = '';
    return new Promise((resolve, reject) => {
        cp.stdout.on('data', data => {
            res += data.toString();
        });
        cp.stderr.on('data', data => {
            coc_nvim_1.workspace.showMessage(`"${cmd} ${args.join(' ')}" error: ${data.toString()}`, 'error');
        });
        cp.on('close', code => {
            if (code != 0) {
                return reject(new Error(`${cmd} exited with code ${code}`));
            }
            resolve(res);
        });
    });
}
exports.runCommandWithData = runCommandWithData;
function runCommand(cmd, opts = {}, timeout) {
    return new Promise((resolve, reject) => {
        let timer;
        if (timeout) {
            timer = setTimeout(() => {
                reject(new Error(`timeout after ${timeout}s`));
            }, timeout * 1000);
        }
        child_process_1.exec(cmd, opts, (err, stdout, stderr) => {
            if (timer)
                clearTimeout(timer);
            if (err) {
                reject(new Error(`exited with ${err.code}\n${stderr}`));
                return;
            }
            resolve(stdout);
        });
    });
}
exports.runCommand = runCommand;
function getStdout(cmd, opts = {}, timeout) {
    return new Promise((resolve, reject) => {
        let timer;
        if (timeout) {
            timer = setTimeout(() => {
                reject(new Error(`timeout after ${timeout}s`));
            }, timeout * 1000);
        }
        child_process_1.exec(cmd, opts, (_err, stdout) => {
            if (timer)
                clearTimeout(timer);
            if (stdout) {
                resolve(stdout);
                return;
            }
            resolve();
        });
    });
}
exports.getStdout = getStdout;
function equals(one, other) {
    if (one === other) {
        return true;
    }
    if (one === null ||
        one === undefined ||
        other === null ||
        other === undefined) {
        return false;
    }
    if (typeof one !== typeof other) {
        return false;
    }
    if (typeof one !== 'object') {
        return false;
    }
    if (Array.isArray(one) !== Array.isArray(other)) {
        return false;
    }
    let i;
    let key;
    if (Array.isArray(one)) {
        if (one.length !== other.length) {
            return false;
        }
        for (i = 0; i < one.length; i++) {
            if (!equals(one[i], other[i])) {
                return false;
            }
        }
    }
    else {
        const oneKeys = [];
        for (key in one) { // tslint:disable-line
            oneKeys.push(key);
        }
        oneKeys.sort();
        const otherKeys = [];
        for (key in other) { // tslint:disable-line
            otherKeys.push(key);
        }
        otherKeys.sort();
        if (!equals(oneKeys, otherKeys)) {
            return false;
        }
        for (i = 0; i < oneKeys.length; i++) {
            if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                return false;
            }
        }
    }
    return true;
}
exports.equals = equals;
//# sourceMappingURL=util.js.map