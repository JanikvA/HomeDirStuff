"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var parsimmon_1 = __importDefault(require("parsimmon"));
var decimal_js_1 = require("decimal.js");
exports.BinaryExponentOptSyms = ['**'];
exports.BinaryMulOptSyms = ['%', '*', '/'];
exports.BinaryAddOptSyms = ['+', '-'];
exports.BinaryOptSyms = exports.BinaryExponentOptSyms.concat(exports.BinaryMulOptSyms, exports.BinaryAddOptSyms);
var BinaryExponentOptClass = /** @class */ (function () {
    function BinaryExponentOptClass() {
    }
    return BinaryExponentOptClass;
}());
exports.BinaryExponentOptClass = BinaryExponentOptClass;
exports.UnaryOptSyms = ['+', '-'];
exports.ConstSyms = [
    'E',
    'LN2',
    'LN10',
    'LOG2E',
    'LOG10E',
    'PI',
    'SQRT1_2',
    'SQRT2'
];
var FuncNameClass = /** @class */ (function () {
    function FuncNameClass() {
        this.abs = [1];
        this.acos = [1];
        this.acosh = [1];
        this.add = [2];
        this.asin = [1];
        this.asinh = [1];
        this.atan = [1];
        this.atanh = [1];
        this.atan2 = [2];
        this.cbrt = [1];
        this.ceil = [1];
        this.cos = [1];
        this.cosh = [1];
        this.div = [2];
        this.exp = [1];
        this.floor = [1];
        this.hypot = [1, Infinity];
        this.ln = [1];
        this.log = [1, 2];
        this.log2 = [1];
        this.log10 = [1];
        this.max = [1, Infinity];
        this.min = [1, Infinity];
        this.mod = [2];
        this.mul = [2];
        this.pow = [2];
        this.random = [0, 1];
        this.round = [1];
        this.sign = [1];
        this.sin = [1];
        this.sinh = [1];
        this.sqrt = [1];
        this.sub = [2];
        this.tan = [1];
        this.tanh = [1];
        this.trunc = [1];
    }
    return FuncNameClass;
}());
exports.FuncNameClass = FuncNameClass;
exports.FuncNameEnum = new FuncNameClass();
var BinaryOpt = /** @class */ (function () {
    function BinaryOpt(raw) {
        this.raw = raw;
    }
    return BinaryOpt;
}());
exports.BinaryOpt = BinaryOpt;
var Node = /** @class */ (function () {
    function Node() {
        this.type = this.constructor.name;
    }
    Node.prototype.registerResult = function (callback) {
        Object.defineProperty(this, 'result', {
            get: callback,
            enumerable: true
        });
    };
    return Node;
}());
exports.Node = Node;
var Decimal = /** @class */ (function (_super) {
    __extends(Decimal, _super);
    function Decimal(raw) {
        var _this = _super.call(this) || this;
        _this.raw = raw;
        _this.registerResult(function () { return new decimal_js_1.Decimal(_this.raw); });
        return _this;
    }
    return Decimal;
}(Node));
exports.Decimal = Decimal;
var Constant = /** @class */ (function (_super) {
    __extends(Constant, _super);
    function Constant(raw) {
        var _this = _super.call(this) || this;
        _this.raw = raw;
        if (!exports.ConstSyms.includes(_this.raw)) {
            throw new Error("Constant " + _this.raw + " not exists");
        }
        _this.constSym = _this.raw;
        _this.registerResult(function () {
            return new decimal_js_1.Decimal(Math[_this.constSym]);
        });
        return _this;
    }
    return Constant;
}(Node));
exports.Constant = Constant;
var FuncCall = /** @class */ (function (_super) {
    __extends(FuncCall, _super);
    function FuncCall(rawFuncName, args) {
        var _this = _super.call(this) || this;
        _this.rawFuncName = rawFuncName;
        _this.args = args;
        if (!(_this.rawFuncName in exports.FuncNameEnum)) {
            throw new Error("Function " + _this.rawFuncName + " not exists");
        }
        _this.funcNameSym = _this.rawFuncName;
        _this = _super.call(this) || this;
        _this.registerResult(function () {
            // @ts-ignore
            return decimal_js_1.Decimal[_this.funcNameSym].apply(decimal_js_1.Decimal, args.map(function (a) { return a.result; }));
        });
        return _this;
    }
    return FuncCall;
}(Node));
exports.FuncCall = FuncCall;
var UnaryExpr = /** @class */ (function (_super) {
    __extends(UnaryExpr, _super);
    function UnaryExpr(operators, value) {
        var _this = _super.call(this) || this;
        _this.operators = operators;
        _this.value = value;
        _this.registerResult(function () {
            return _this.operator === '+'
                ? new decimal_js_1.Decimal(_this.value.result)
                : new decimal_js_1.Decimal(0).sub(_this.value.result);
        });
        return _this;
    }
    Object.defineProperty(UnaryExpr.prototype, "operator", {
        get: function () {
            return this.operators.reduce(function (ret, o) { return ret * (o === '+' ? 1 : -1); }, 1) === 1 ? '+' : '-';
        },
        enumerable: true,
        configurable: true
    });
    return UnaryExpr;
}(Node));
exports.UnaryExpr = UnaryExpr;
var BinaryExpr = /** @class */ (function (_super) {
    __extends(BinaryExpr, _super);
    function BinaryExpr(left, operator, right) {
        var _this = _super.call(this) || this;
        _this.left = left;
        _this.operator = operator;
        _this.right = right;
        _this.registerResult(function () { return BinaryExpr.calculate(_this); });
        return _this;
    }
    BinaryExpr.calculate = function (expr) {
        var l = expr.left.result;
        var r = expr.right.result;
        return {
            '+': function () { return l.add(r); },
            '-': function () { return l.minus(r); },
            '*': function () { return l.mul(r); },
            '/': function () { return l.div(r); },
            '%': function () { return l.modulo(r); },
            '**': function () { return l.pow(r); }
        }[expr.operator.raw]();
    };
    return BinaryExpr;
}(Node));
exports.BinaryExpr = BinaryExpr;
exports.whitespaceP = parsimmon_1.default.optWhitespace;
var _ = exports.whitespaceP;
exports.leftParenthesisP = parsimmon_1.default.string('(').trim(_);
exports.rightParenthesisP = parsimmon_1.default.string(')').trim(_);
exports.ofStringArrayP = function () {
    var strs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        strs[_i] = arguments[_i];
    }
    return parsimmon_1.default.alt.apply(parsimmon_1.default, strs.map(function (s) { return parsimmon_1.default.string(s); }));
};
exports.optionalParenthesisP = function (parser) {
    return parsimmon_1.default.alt(parser, parser.wrap(exports.leftParenthesisP, exports.rightParenthesisP), parsimmon_1.default.lazy(function () {
        return exports.optionalParenthesisP(parser).wrap(exports.leftParenthesisP, exports.rightParenthesisP);
    }));
};
exports.decimalP = parsimmon_1.default.regexp(/(\d+(\.\d+)?|(\.\d+))(e[-+]?\d+)?(p[-+]?\d+)?/)
    .map(function (str) { return new Decimal(str); })
    .desc('decimal');
exports.includesP = function (ss) { return parsimmon_1.default.alt.apply(parsimmon_1.default, ss.map(function (s) { return parsimmon_1.default.string(s); })); };
// export const constantP = P.regexp(/[A-Z_][A-Z_0-9]*/)
exports.constantP = exports.includesP(exports.ConstSyms)
    .map(function (str) { return new Constant(str); })
    .desc('constant');
// export const funcNameP = P.regexp(/[A-Z_a-z]\w*/).desc('functionName');
exports.funcNameP = exports.includesP(Object.keys(exports.FuncNameEnum))
    .desc('functionName');
exports.funcCallP = parsimmon_1.default.lazy(function () {
    return parsimmon_1.default.seq(exports.funcNameP, parsimmon_1.default.sepBy(exports.exprP, parsimmon_1.default.string(',').trim(_)).wrap(exports.leftParenthesisP, exports.rightParenthesisP)).map(function (_a) {
        var name = _a[0], args = _a[1];
        return new FuncCall(name, args);
    });
}).desc('constant');
exports.atomicP = exports.optionalParenthesisP(parsimmon_1.default.alt(exports.funcCallP, exports.constantP, exports.decimalP)).desc('atomic');
exports.unaryOptP = exports.ofStringArrayP.apply(void 0, exports.UnaryOptSyms).trim(_)
    .desc('unaryOperator');
exports.unaryExprP = parsimmon_1.default.lazy(function () {
    return exports.optionalParenthesisP(parsimmon_1.default.alt(parsimmon_1.default.seq(exports.unaryOptP.many(), exports.atomicP).map(function (_a) {
        var unaryOperators = _a[0], decimal = _a[1];
        return new UnaryExpr(unaryOperators, decimal);
    }), exports.atomicP));
}).desc('unaryExpression');
exports.binaryOptP = exports.ofStringArrayP.apply(void 0, exports.BinaryOptSyms).trim(_)
    .map(function (str) { return new BinaryOpt(str); })
    .desc('binaryOperator');
exports.binaryCalculate = function (left) {
    var rest = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        rest[_i - 1] = arguments[_i];
    }
    var nodeStack = [];
    var optStack = [];
    nodeStack.unshift(left);
    var arithmeticCalc = function (opts) {
        var _nodeStack = [];
        var _optStack = [];
        while (optStack.length && opts.includes(optStack[0].raw)) {
            if (_nodeStack.length === 0)
                _nodeStack.unshift(nodeStack.shift());
            _optStack.unshift(optStack.shift());
            _nodeStack.unshift(nodeStack.shift());
        }
        if (_nodeStack.length > 0) {
            var left_1 = _nodeStack.shift();
            while (_optStack.length > 0) {
                var op = _optStack.shift();
                var right = _nodeStack.shift();
                left_1 = new BinaryExpr(left_1, op, right);
            }
            nodeStack.unshift(left_1);
        }
    };
    var exponentCalc = function () {
        while (optStack.length &&
            exports.BinaryExponentOptSyms.includes(optStack[0].raw)) {
            var op = optStack.shift();
            var right = nodeStack.shift();
            var left_2 = nodeStack.shift();
            nodeStack.unshift(new BinaryExpr(left_2, op, right));
        }
    };
    while (rest.length > 0) {
        var _a = rest.shift(), op = _a[0], expr = _a[1];
        if (exports.BinaryExponentOptSyms.includes(op.raw)) {
            optStack.unshift(op);
            nodeStack.unshift(expr);
        }
        else if (exports.BinaryMulOptSyms.includes(op.raw)) {
            exponentCalc();
            optStack.unshift(op);
            nodeStack.unshift(expr);
        }
        else if (exports.BinaryAddOptSyms.includes(op.raw)) {
            exponentCalc();
            arithmeticCalc(exports.BinaryMulOptSyms);
            optStack.unshift(op);
            nodeStack.unshift(expr);
        }
    }
    exponentCalc();
    arithmeticCalc(exports.BinaryMulOptSyms);
    arithmeticCalc(exports.BinaryAddOptSyms);
    return nodeStack.shift();
};
exports.binaryOptExprP = parsimmon_1.default.lazy(function () {
    var unaryP = function (parser) {
        return parsimmon_1.default.alt(parsimmon_1.default.seq(exports.unaryOptP.many(), parser).map(function (_a) {
            var unaryOpts = _a[0], expr = _a[1];
            return new UnaryExpr(unaryOpts, expr);
        }), parser);
    };
    var exprP = exports.optionalParenthesisP(parsimmon_1.default.seqMap(parsimmon_1.default.alt(unaryP(exports.binaryOptExprP.wrap(exports.leftParenthesisP, exports.rightParenthesisP)), exports.unaryExprP), parsimmon_1.default.seq(exports.binaryOptP, parsimmon_1.default.alt(unaryP(exports.binaryOptExprP.wrap(exports.leftParenthesisP, exports.rightParenthesisP)), exports.unaryExprP)).atLeast(1), function (left, _a) {
        var rest = _a.slice(0);
        return exports.binaryCalculate.apply(void 0, [left].concat(rest));
    }));
    return unaryP(exprP);
});
exports.exprP = parsimmon_1.default.alt(exports.binaryOptExprP, exports.unaryExprP)
    .trim(_)
    .desc('expression');
exports.skipEqualSignP = parsimmon_1.default.string('=').trim(_).times(0, 1);
exports.mainP = exports.exprP.skip(exports.skipEqualSignP).desc('main');
exports.parse = function (text) { return exports.mainP.tryParse(text); };
exports.printAst = function (text) {
    var ast = exports.parse(text);
    console.log(JSON.stringify(ast, null, 2));
};
exports.calculate = function (text, skip, skipRecords, originText) {
    if (skip === void 0) { skip = 0; }
    if (skipRecords === void 0) { skipRecords = []; }
    if (originText === void 0) { originText = text; }
    try {
        var ast = exports.parse(text);
        return {
            skip: skip,
            result: ast.result.valueOf()
        };
    }
    catch (e) {
        if (e.type === 'ParsimmonError') {
            if (e.result.index.offset < 1) {
                skipRecords.push(0);
            }
            var offset = Math.max(1, e.result.index.offset);
            if (offset < text.length - 1) {
                var newSkip = skip + offset;
                return exports.calculate(text.slice(offset), newSkip, skipRecords.concat([newSkip]), originText);
            }
        }
        var highlightSkipRecords = Array.from(Array(originText.length))
            .map(function (_, index) { return skipRecords.includes(index) ? '✗' : ' '; })
            .join('');
        throw new Error(['CalculateError:', originText, highlightSkipRecords].join('\r\n'));
    }
};
