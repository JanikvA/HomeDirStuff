"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = require("../util");
const safe_1 = tslib_1.__importDefault(require("colors/safe"));
const STATUS_MAP = {
    ' ': ' ',
    M: safe_1.default.cyan('~'),
    A: safe_1.default.green('+'),
    D: safe_1.default.red('-'),
    R: safe_1.default.magenta('â†’'),
    C: safe_1.default.yellow('C'),
    U: safe_1.default.blue('U'),
    '?': safe_1.default.gray('?')
};
class GStatus extends coc_nvim_1.BasicList {
    constructor(nvim, manager) {
        super(nvim);
        this.manager = manager;
        this.name = 'gstatus';
        this.description = 'Git status of current project';
        this.defaultAction = 'open';
        this.actions = [];
        this.addLocationActions();
        this.addMultipleAction('add', (items) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { root } = items[0].data;
            let fileArgs = items.map(o => o.data.relative);
            yield util_1.spawnCommand('git', ['add', ...fileArgs], root);
        }), { reload: true, persist: true });
        this.addMultipleAction('patch', (items) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { root } = items[0].data;
            let fileArgs = items.map(o => o.data.relative.replace(/\s/, '\\ '));
            let cmd = `git add ${fileArgs.join(' ')} --patch`;
            yield nvim.call('coc#util#open_terminal', [{
                    cmd,
                    cwd: root
                }]);
        }));
        this.addMultipleAction('commit', (items) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { root } = items[0].data;
            yield nvim.command(`exe "lcd ".fnameescape('${root}')`);
            let filesArg = yield nvim.eval(`join(map([${items.map(s => "'" + s.data.relative + "'").join(',')}],'fnameescape(v:val)'),' ')`);
            try {
                yield nvim.command(`Gcommit -v ${filesArg}`);
            }
            catch (e) {
                coc_nvim_1.workspace.showMessage(`Gcommit command failed, make sure fugitive installed.`, 'error');
            }
        }));
        this.addAction('reset', (item) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { staged, tree, relative, root } = item.data;
            if (staged && tree) {
                let choices = ['&Reset', '&Checkout'];
                let n = yield nvim.call('confirm', [`Choose action for ${relative}:`, choices.join('\n')]);
                if (!n || n < 1)
                    return;
                if (n == 1) {
                    yield this.reset(root, relative);
                }
                else {
                    yield this.checkout(root, relative);
                }
            }
            else if (tree) {
                yield this.checkout(root, relative);
            }
            else if (staged) {
                yield this.reset(root, relative);
            }
            else {
                let confirmed = yield coc_nvim_1.workspace.showPrompt(`remove ${relative}?`);
                if (!confirmed)
                    return;
                let hasRmtrash = yield nvim.call('executable', ['rmtrash']);
                let fullpath = path_1.default.join(root, relative);
                if (hasRmtrash) {
                    yield util_1.runCommand(`rmtrash ${fullpath.replace(/\s/, '\\ ')}`);
                }
                else {
                    fs_1.default.unlinkSync(fullpath);
                }
            }
        }), { reload: true, persist: true });
        // preview the diff
        this.addAction('preview', (item, context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { tree_symbol, root, relative } = item.data;
            if (tree_symbol != 'M') {
                yield this.previewLocation({
                    uri: coc_nvim_1.Uri.file(path_1.default.join(root, relative)).toString(),
                    range: {
                        start: { line: 0, character: 0 },
                        end: { line: 0, character: 0 }
                    }
                }, context);
                return;
            }
            let args = ['--no-pager', 'diff'];
            let winid = context.listWindow.id;
            let cmd = `git ${args.join(' ')} ${relative}`;
            let content = yield util_1.runCommand(cmd, { cwd: root });
            let lines = content.trim().split('\n');
            let mod = context.options.position == 'top' ? 'below' : 'above';
            let height = Math.min(this.previewHeight, lines.length);
            yield nvim.command('pclose');
            nvim.pauseNotification();
            nvim.command(`${mod} ${height}sp +setl\\ previewwindow [diff]`, true);
            nvim.command('setl winfixheight buftype=nofile nofoldenable', true);
            nvim.command('setl nobuflisted bufhidden=wipe', true);
            nvim.command('setf diff', true);
            nvim.call('append', [0, lines], true);
            nvim.command('normal! Gdd', true);
            nvim.command(`exe 1`, true);
            nvim.call('win_gotoid', [winid], true);
            yield nvim.resumeNotification();
        }));
    }
    reset(root, relative) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield util_1.spawnCommand('git', ['reset', 'HEAD', '--', relative], root);
        });
    }
    checkout(root, relative) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield util_1.spawnCommand('git', ['checkout', '--', relative], root);
        });
    }
    loadItems(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let buf = yield context.window.buffer;
            let root = yield this.manager.resolveGitRoot(buf.id);
            if (!root) {
                throw new Error(`Can't resolve git root.`);
                return;
            }
            let output = yield util_1.runCommand(`git status --porcelain -uall ${context.args.join(' ')}`, { cwd: root });
            output = output.replace(/\s+$/, '');
            if (!output)
                return [];
            // let root = this.manager.refreshStatus
            let res = [];
            for (let line of output.split(/\r?\n/)) {
                let filepath = path_1.default.join(root, line.slice(3));
                let index_symbol = STATUS_MAP[line[0]];
                let tree_symbol = STATUS_MAP[line[1]];
                res.push({
                    label: `${index_symbol}${tree_symbol} ${line.slice(3)}`,
                    filterText: line.slice(3),
                    data: {
                        root,
                        relative: line.slice(3),
                        index_symbol: line[0],
                        tree_symbol: line[1],
                        staged: line[0] != ' ' && line[0] != '?',
                        tree: line[1] != ' ' && line[1] != '?',
                    },
                    location: coc_nvim_1.Uri.file(filepath).toString()
                });
            }
            return res;
        });
    }
}
exports.default = GStatus;
//# sourceMappingURL=gstatus.js.map