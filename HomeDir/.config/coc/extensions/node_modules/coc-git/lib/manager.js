"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const status_1 = require("./status");
const path_1 = tslib_1.__importDefault(require("path"));
const helper_1 = require("./helper");
const diff_1 = require("./diff");
const types_1 = require("./types");
const util_1 = require("./util");
class DocumentManager {
    constructor(nvim, resolver) {
        this.nvim = nvim;
        this.resolver = resolver;
        this.cachedDiffs = new Map();
        this.cachedSigns = new Map();
        this.foldSettingsMap = new Map();
        this.enabledFolds = new Set();
        this.disposables = [];
        this.floatFactory = new coc_nvim_1.FloatFactory(nvim, coc_nvim_1.workspace.env, false, 20, false, 300);
        this.config = coc_nvim_1.workspace.getConfiguration('git');
        coc_nvim_1.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('git')) {
                this.config = coc_nvim_1.workspace.getConfiguration('git');
            }
        }, null, this.disposables);
        this.init().catch(e => {
            // tslint:disable-next-line: no-console
            console.error(e);
        });
        let blame = this.config.get('addGlameToVirtualText', false);
        if (blame && coc_nvim_1.workspace.isNvim) {
            nvim.createNamespace('coc-git').then(srcId => {
                this.virtualTextSrcId = srcId;
            }, _e => {
                // noop
            });
            coc_nvim_1.events.on('CursorHold', this.showBlameInfo, this, this.disposables);
            coc_nvim_1.events.on('CursorMoved', () => {
                this.curseMoveTs = Date.now();
            }, null, this.disposables);
        }
    }
    showBlameInfo(bufnr) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { virtualTextSrcId, nvim } = this;
            if (!virtualTextSrcId)
                return;
            let ts = Date.now();
            let blame = this.config.get('addGlameToVirtualText', false);
            if (!blame)
                return;
            let doc = coc_nvim_1.workspace.getDocument(bufnr);
            if (!doc || doc.schema != 'file' || doc.isIgnored)
                return;
            let root = yield this.resolveGitRoot(bufnr);
            if (!root || this.curseMoveTs > ts)
                return;
            let lnum = yield nvim.call('line', '.');
            let filepath = coc_nvim_1.Uri.parse(doc.uri).fsPath;
            let relpath = path_1.default.relative(root, filepath);
            let res = yield util_1.safeRun(`git --no-pager blame -b --root -L${lnum},${lnum} --date relative ${relpath}`);
            if (!res)
                return;
            let match = res.split(/\r?\n/)[0].match(/^\w+\s\((.+?)\s*\d+\)/);
            if (!match)
                return;
            if (coc_nvim_1.workspace.insertMode || this.curseMoveTs > ts)
                return;
            let buffer = nvim.createBuffer(bufnr);
            let modified = yield buffer.getOption('modified');
            if (modified)
                return;
            yield nvim.request('nvim_buf_clear_namespace', [buffer, virtualTextSrcId, 0, -1]);
            yield buffer.setVirtualText(virtualTextSrcId, lnum - 1, [[match[1], 'CocCodeLens']]);
        });
    }
    get signOffset() {
        return this.config.get('signOffset', 99);
    }
    get enableGutters() {
        return this.config.get('enableGutters', true);
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { nvim, config } = this;
            if (this.enableGutters) {
                let items = ['Changed', 'Added', 'Removed', 'TopRemoved', 'ChangeRemoved'];
                nvim.pauseNotification();
                for (let item of items) {
                    let section = item[0].toLowerCase() + item.slice(1) + 'Sign';
                    let text = config.get(`${section}.text`, '');
                    let hlGroup = config.get(`${section}.hlGroup`, '');
                    nvim.command(`sign define CocGit${item} text=${text} texthl=CocGit${item}Sign`, true);
                    nvim.command(`hi default link CocGit${item}Sign ${hlGroup}`, true);
                }
                yield nvim.resumeNotification();
            }
        });
    }
    toggleGutters() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let enabled = this.enableGutters;
            this.config.update('enableGutters', !enabled, true);
            if (enabled) {
                // disable
                this.nvim.pauseNotification();
                for (let [bufnr, cached] of this.cachedSigns.entries()) {
                    this.nvim.call('coc#util#unplace_signs', [bufnr, cached.map(o => o.signId)], true);
                    this.cachedSigns.clear();
                }
                yield this.nvim.resumeNotification();
            }
            else {
                this.cachedDiffs.clear();
                this.cachedSigns.clear();
                // enable
                for (let doc of coc_nvim_1.workspace.documents) {
                    this.diffDocument(doc).catch(_e => {
                        // noop
                    });
                }
            }
        });
    }
    toggleFold() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { nvim } = this;
            let buf = yield nvim.buffer;
            let win = yield nvim.window;
            let bufnr = buf.id;
            let doc = coc_nvim_1.workspace.getDocument(bufnr);
            if (!doc)
                return;
            let infos = this.cachedSigns.get(bufnr);
            if (!infos || infos.length == 0) {
                coc_nvim_1.workspace.showMessage('No changes', 'warning');
                return;
            }
            let enabled = this.enabledFolds.has(bufnr);
            if (enabled) {
                this.enabledFolds.delete(bufnr);
                let settings = this.foldSettingsMap.get(bufnr);
                nvim.pauseNotification();
                win.setOption('foldmethod', settings.foldmethod, true);
                win.setOption('foldenable', settings.foldenable, true);
                win.setOption('foldlevel', settings.foldlevel, true);
                yield nvim.resumeNotification();
            }
            else {
                this.enabledFolds.add(bufnr);
                let settings = {
                    foldmethod: yield win.getOption('foldmethod'),
                    foldenable: yield win.getOption('foldenable'),
                    foldlevel: yield win.getOption('foldlevel')
                };
                this.foldSettingsMap.set(bufnr, settings);
                nvim.pauseNotification();
                win.setOption('foldmethod', 'manual', true);
                win.setOption('foldenable', true, true);
                win.setOption('foldlevel', 0, true);
                yield nvim.resumeNotification();
                let lnums = infos.map(o => o.lnum);
                let ranges = [];
                let start = null;
                for (let i = 1; i <= doc.lineCount; i++) {
                    let fold = lnums.indexOf(i) == -1;
                    if (fold && start == null) {
                        start = i;
                        continue;
                    }
                    if (start != null && !fold) {
                        ranges.push([start, i - 1]);
                        start = null;
                    }
                    if (start != null && fold && i == doc.lineCount) {
                        ranges.push([start, i]);
                    }
                }
                nvim.pauseNotification();
                for (let r of ranges) {
                    nvim.command(`${r[0]},${r[1]}fold`, true);
                }
                yield nvim.resumeNotification();
            }
        });
    }
    refreshStatus() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { nvim, bufnr } = coc_nvim_1.workspace;
            const doc = coc_nvim_1.workspace.getDocument(bufnr);
            let root;
            if (doc && doc.schema == 'file') {
                root = this.resolver.getGitRoot(coc_nvim_1.Uri.parse(doc.uri).fsPath);
            }
            else {
                root = yield this.resolver.resolveGitRoot();
            }
            let character = this.config.get('branchCharacter', '');
            if (!root) {
                nvim.setVar('coc_git_status', '', true);
            }
            else {
                const changedDecorator = this.config.get('changedDecorator', '*');
                const conflictedDecorator = this.config.get('conflictedDecorator', 'x');
                const stagedDecorator = this.config.get('stagedDecorator', '●');
                const untrackedDecorator = this.config.get('untrackedDecorator', '…');
                let status = yield status_1.gitStatus(root, character, {
                    changedDecorator,
                    conflictedDecorator,
                    stagedDecorator,
                    untrackedDecorator,
                });
                if (coc_nvim_1.workspace.bufnr != bufnr)
                    return;
                nvim.setVar('coc_git_status', status, true);
            }
        });
    }
    resolveGitRoot(bufnr) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let doc = coc_nvim_1.workspace.getDocument(bufnr);
            return this.resolver.resolveGitRoot(doc);
        });
    }
    getCurrentChunk() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { nvim } = this;
            let bufnr = yield nvim.call('bufnr', '%');
            let line = yield nvim.call('line', '.');
            let diffs = this.cachedDiffs.get(bufnr);
            if (!diffs || diffs.length == 0)
                return;
            return diffs.find(ch => {
                let { start, delta } = ch;
                if (line == 1 && start == 0 && ch.end == 0) {
                    return true;
                }
                let end = delta && delta[0] > delta[1] ? ch.end + delta[0] - delta[1] : ch.end;
                if (start <= line && end >= line) {
                    return true;
                }
                return false;
            });
        });
    }
    showDoc(content, filetype = 'diff') {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (coc_nvim_1.workspace.env.floating) {
                let docs = [{ content, filetype }];
                yield this.floatFactory.create(docs, false);
            }
            else {
                const lines = ['``` ' + filetype];
                lines.push(...content.split('\n'));
                lines.push('```');
                this.nvim.call('coc#util#preview_info', [lines], true);
            }
        });
    }
    chunkInfo() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let diff = yield this.getCurrentChunk();
            if (diff) {
                let content = diff.head + '\n' + diff.lines.join('\n');
                yield this.showDoc(content, 'diff');
            }
        });
    }
    nextChunk() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { nvim } = this;
            let bufnr = yield nvim.call('bufnr', '%');
            let diffs = this.cachedDiffs.get(bufnr);
            if (!diffs || diffs.length == 0)
                return;
            let line = yield nvim.call('line', '.');
            for (let diff of diffs) {
                if (diff.start > line) {
                    yield coc_nvim_1.workspace.moveTo({ line: Math.max(diff.start - 1, 0), character: 0 });
                    return;
                }
            }
        });
    }
    prevChunk() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { nvim } = this;
            let bufnr = yield nvim.call('bufnr', '%');
            let line = yield nvim.call('line', '.');
            let diffs = this.cachedDiffs.get(bufnr);
            if (!diffs || diffs.length == 0)
                return;
            for (let diff of diffs.slice().reverse()) {
                if (diff.end < line) {
                    yield coc_nvim_1.workspace.moveTo({ line: Math.max(diff.start - 1, 0), character: 0 });
                    return;
                }
            }
        });
    }
    diffDocument(doc) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { nvim } = coc_nvim_1.workspace;
            let root = this.resolver.getRootOfDocument(doc);
            if (!root)
                return;
            const diffs = yield diff_1.getDiff(root, doc);
            const { bufnr } = doc;
            this.cachedDiffs.set(bufnr, diffs || []);
            const cached = this.cachedSigns.get(bufnr);
            if (!diffs || diffs.length == 0) {
                let buf = doc.buffer;
                buf.setVar('coc_git_status', '', true);
                if (cached && cached.length && this.enableGutters) {
                    nvim.call('coc#util#unplace_signs', [bufnr, cached.map(o => o.signId)], true);
                    this.cachedSigns.set(bufnr, []);
                }
            }
            else {
                let added = 0;
                let changed = 0;
                let removed = 0;
                let signs = [];
                let signId = this.signOffset;
                for (let diff of diffs) {
                    if (diff.changeType == types_1.ChangeType.Add) {
                        added += diff.lines.length;
                    }
                    else if (diff.changeType == types_1.ChangeType.Delete) {
                        removed += diff.lines.length;
                    }
                    else if (diff.changeType == types_1.ChangeType.Change) {
                        let [add, remove] = diff.delta;
                        let min = Math.min(add, remove);
                        changed += min;
                        add += add - min;
                        remove += remove - min;
                    }
                    let { start, end } = diff;
                    for (let i = start; i <= end; i++) {
                        let topdelete = diff.changeType == types_1.ChangeType.Delete && i == 0;
                        let bottomdelete = diff.changeType == types_1.ChangeType.Change && diff.delta[1] > diff.delta[0] && i == end;
                        signs.push({
                            signId,
                            changeType: topdelete ? 'topdelete' : bottomdelete ? 'bottomdelete' : diff.changeType,
                            lnum: topdelete ? 1 : i
                        });
                        signId = signId + 1;
                    }
                    if (diff.changeType == types_1.ChangeType.Change) {
                        let [add, remove] = diff.delta;
                        if (add > remove) {
                            for (let i = 0; i < add - remove; i++) {
                                signs.push({
                                    signId,
                                    changeType: types_1.ChangeType.Add,
                                    lnum: diff.end + 1 + i
                                });
                                signId = signId + 1;
                            }
                        }
                    }
                }
                let items = [];
                if (added)
                    items.push(`+${added}`);
                if (changed)
                    items.push(`~${changed}`);
                if (removed)
                    items.push(`-${removed}`);
                let status = '  ' + `${items.join(' ')} `;
                nvim.pauseNotification();
                doc.buffer.setVar('coc_git_status', status, true);
                if (this.enableGutters) {
                    if (cached)
                        nvim.call('coc#util#unplace_signs', [bufnr, cached.map(o => o.signId)], true);
                    this.cachedSigns.set(bufnr, signs);
                    for (let sign of signs) {
                        let name = this.getSignName(sign.changeType);
                        let cmd = `sign place ${sign.signId} line=${sign.lnum} name=${name} buffer=${bufnr}`;
                        nvim.command(cmd, true);
                    }
                }
                yield nvim.resumeNotification();
            }
        });
    }
    getSignName(changeType) {
        switch (changeType) {
            case types_1.ChangeType.Delete:
                return 'CocGitRemoved';
            case types_1.ChangeType.Add:
                return 'CocGitAdded';
            case types_1.ChangeType.Change:
                return 'CocGitChanged';
            case 'topdelete':
                return 'CocGitTopRemoved';
            case 'bottomdelete':
                return 'CocGitChangeRemoved';
        }
        return '';
    }
    chunkStage() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let bufnr = yield this.nvim.call('bufnr', '%');
            let doc = coc_nvim_1.workspace.getDocument(bufnr);
            if (!doc)
                return;
            let diff = yield this.getCurrentChunk();
            if (!diff)
                return;
            let root = this.resolver.getRootOfDocument(doc);
            let filepath = path_1.default.relative(root, coc_nvim_1.Uri.parse(doc.uri).fsPath);
            const lines = [
                `diff --git a/${filepath} b/${filepath}`,
                `index 000000..000000 100644`,
                `--- a/${filepath}`,
                `+++ b/${filepath}`,
                diff.head
            ];
            lines.push(...diff.lines);
            lines.push('');
            try {
                yield util_1.runCommandWithData('git', ['apply', '--cached', '--unidiff-zero', '-'], root, lines.join('\n'));
            }
            catch (e) {
                // tslint:disable-next-line: no-console
                console.error(e);
            }
        });
    }
    chunkUndo() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let diff = yield this.getCurrentChunk();
            if (!diff)
                return;
            let { start, lines, changeType } = diff;
            let added = lines.filter(s => s.startsWith('-')).map(s => s.slice(1));
            let removeCount = lines.filter(s => s.startsWith('+')).length;
            let { nvim } = this;
            let buf = yield nvim.buffer;
            if (changeType == types_1.ChangeType.Delete) {
                yield buf.setLines(added, { start, end: start, strictIndexing: false });
            }
            else {
                yield buf.setLines(added, {
                    start: start - 1,
                    end: start - 1 + removeCount,
                    strictIndexing: false
                });
            }
        });
    }
    // show commit of current line in floating window
    showCommit() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { nvim } = this;
            let bufnr = yield nvim.call('bufnr', '%');
            let root = yield this.resolveGitRoot(bufnr);
            if (!root) {
                coc_nvim_1.workspace.showMessage(`not a git repository.`, 'warning');
                return;
            }
            let fullpath = yield nvim.eval('expand("%:p")');
            let relpath = path_1.default.relative(root, fullpath);
            let res = yield util_1.safeRun(`git ls-files -- ${relpath}`, { cwd: root });
            if (!res.length) {
                coc_nvim_1.workspace.showMessage(`"${relpath}" not indexed.`, 'warning');
                return;
            }
            let line = yield nvim.eval('line(".")');
            let args = ['--no-pager', 'blame', '-l', '--root', '-t', `-L${line},${line}`, relpath];
            let output = yield util_1.spawnCommand('git', args, root);
            output = output.trim();
            if (!output.length)
                return;
            let commit = output.match(/^\S+/)[0];
            if (/^0+$/.test(commit)) {
                yield this.showDoc('not committed yet!', 'txt');
                return;
            }
            yield nvim.command('keepalt above sp');
            let hasFugitive = yield nvim.getVar('loaded_fugitive');
            if (hasFugitive) {
                yield nvim.command(`Gedit ${commit}`);
            }
            else {
                let content = yield util_1.runCommand(`git --no-pager show ${commit}`, { cwd: root });
                let lines = content.trim().split('\n');
                nvim.pauseNotification();
                nvim.command(`edit +setl\\ buftype=nofile [commit ${commit}]`, true);
                nvim.command('setl foldmethod=syntax nobuflisted bufhidden=wipe', true);
                nvim.command('setf git', true);
                nvim.call('append', [0, lines], true);
                nvim.command('normal! Gdd', true);
                nvim.command(`exe 1`, true);
                yield nvim.resumeNotification();
            }
        });
    }
    browserOpen(action = 'open') {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { nvim } = this;
            let bufnr = yield nvim.call('bufnr', '%');
            let root = yield this.resolveGitRoot(bufnr);
            if (!root) {
                coc_nvim_1.workspace.showMessage(`not a git repository.`, 'warning');
                return;
            }
            // get remote list
            let output = yield util_1.safeRun('git remote', { cwd: root });
            if (!output.trim()) {
                coc_nvim_1.workspace.showMessage(`No remote found`, 'warning');
                return;
            }
            let head = yield util_1.safeRun('git symbolic-ref --short -q HEAD', { cwd: root });
            head = head.trim();
            if (!head.length) {
                coc_nvim_1.workspace.showMessage(`Failed on git symbolic-ref`, 'warning');
                return;
            }
            const mode = yield nvim.call('mode');
            const lines = (mode.toLowerCase() === 'v') ? [
                yield nvim.eval(`line("'<")`),
                yield nvim.eval(`line(">'")`),
            ] : [yield nvim.eval('line(".")')];
            let fullpath = yield nvim.eval('expand("%:p")');
            let relpath = path_1.default.relative(root, fullpath);
            let names = output.trim().split(/\r?\n/);
            let urls = [];
            for (let name of names) {
                let uri = yield util_1.safeRun(`git remote get-url ${name}`, { cwd: root });
                uri = uri.replace(/\s+$/, '');
                if (!uri.length)
                    continue;
                let url = helper_1.getUrl(uri, head, relpath, lines);
                if (url)
                    urls.push(url);
            }
            if (urls.length == 1) {
                if (action == 'open') {
                    nvim.call('coc#util#open_url', [urls[0]], true);
                }
                else {
                    nvim.command(`let @+ = '${urls[0]}'`, true);
                    coc_nvim_1.workspace.showMessage('Copied url to clipboard');
                }
            }
            else if (urls.length > 1) {
                let idx = yield coc_nvim_1.workspace.showQuickpick(urls, 'Select url:');
                if (idx >= 0) {
                    if (action == 'open') {
                        nvim.call('coc#util#open_url', [urls[idx]], true);
                    }
                    else {
                        nvim.command(`let @+ = '${urls[idx]}'`, true);
                        coc_nvim_1.workspace.showMessage('Copied url to clipboard');
                    }
                }
            }
        });
    }
    diffCached() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { nvim } = this;
            let bufnr = yield nvim.call('bufnr', '%');
            let root = yield this.resolveGitRoot(bufnr);
            if (!root) {
                coc_nvim_1.workspace.showMessage(`not a git repository.`, 'warning');
                return;
            }
            let res = yield util_1.safeRun(`git diff --cached`, { cwd: root });
            if (!res.trim()) {
                coc_nvim_1.workspace.showMessage('Empty diff');
                return;
            }
            nvim.pauseNotification();
            nvim.command(`keepalt above new +setl\\ previewwindow`, true);
            nvim.call('append', [0, res.split(/\r?\n/)], true);
            nvim.command('normal! Gdd', true);
            nvim.command(`exe 1`, true);
            nvim.command('setfiletype git', true);
            nvim.command('setl buftype=nofile nomodifiable bufhidden=wipe nobuflisted', true);
            yield nvim.resumeNotification();
        });
    }
    dispose() {
        coc_nvim_1.disposeAll(this.disposables);
    }
}
exports.default = DocumentManager;
//# sourceMappingURL=manager.js.map