"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const util_1 = require("../util");
const path_1 = tslib_1.__importDefault(require("path"));
class Gfiles extends coc_nvim_1.BasicList {
    constructor(nvim, manager) {
        super(nvim);
        this.manager = manager;
        this.name = 'gfiles';
        this.description = 'view files on different branches (or commits, or tags)';
        this.detail = 'Pass git sha as first command argument, when empty, HEAD is used.\nExample: :CocList gfiles 7b5c5cb';
        this.defaultAction = 'show';
        this.actions = [];
        this.addAction('show', (item) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { root, sha, filepath, branch } = item.data;
            if (!sha)
                return;
            let content = yield util_1.runCommand(`git cat-file -p ${sha}`, { cwd: root });
            let lines = content.replace(/\n$/, '').split('\n');
            let file = path_1.default.relative(root, filepath);
            nvim.pauseNotification();
            nvim.command(`exe "edit ".fnameescape('(${branch}) ${file}')`, true);
            nvim.call('append', [0, lines], true);
            nvim.command('normal! Gdd', true);
            nvim.command(`exe 1`, true);
            nvim.command('setl buftype=nofile nomodifiable bufhidden=wipe nobuflisted', true);
            nvim.command('filetype detect', true);
            yield nvim.resumeNotification();
        }));
        this.addAction('preview', (item, context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { root, sha, filepath, branch } = item.data;
            if (!sha)
                return;
            let content = yield util_1.runCommand(`git --no-pager diff ${branch} -- ${filepath}`, { cwd: root });
            let lines = content.replace(/\n$/, '').split('\n');
            let mod = context.options.position == 'top' ? 'below' : 'above';
            let winid = context.listWindow.id;
            nvim.pauseNotification();
            nvim.command('pclose', true);
            nvim.command(`${mod} ${this.previewHeight}sp +setl\\ previewwindow (diff ${branch}) ${path_1.default.basename(filepath)}`, true);
            nvim.call('append', [0, lines], true);
            nvim.command('normal! Gdd', true);
            nvim.command(`exe 1`, true);
            nvim.command('setl buftype=nofile nomodifiable bufhidden=wipe nobuflisted', true);
            nvim.command('setf diff', true);
            nvim.call('win_gotoid', [winid], true);
            yield nvim.resumeNotification();
        }), { persist: true, reload: false });
    }
    loadItems(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let buf = yield context.window.buffer;
            let root = yield this.manager.resolveGitRoot(buf.id);
            if (!root) {
                throw new Error(`Can't resolve git root.`);
                return;
            }
            const { args } = context;
            let arg = args.length ? args.join(' ') : 'HEAD';
            let output = yield util_1.runCommand(`git ls-tree -r ${arg}`, { cwd: root });
            output = output.replace(/\s+$/, '');
            if (!output)
                return [];
            // let root = this.manager.refreshStatus
            let res = [];
            for (let line of output.split(/\r?\n/)) {
                let [head, filepath] = line.split('\t', 2);
                let sha = head.split(" ")[2];
                res.push({
                    label: filepath,
                    data: {
                        branch: args[0] || 'HEAD',
                        filepath,
                        root,
                        sha
                    }
                });
            }
            return res;
        });
    }
}
exports.default = Gfiles;
//# sourceMappingURL=gfiles.js.map