"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const coc_nvim_1 = require("coc.nvim");
const events_1 = require("events");
const readline_1 = tslib_1.__importDefault(require("readline"));
const util_1 = require("../util");
class CommitsTask extends events_1.EventEmitter {
    constructor(root) {
        super();
        this.root = root;
    }
    start(cmd, args, cwd) {
        this.process = child_process_1.spawn(cmd, args, { cwd });
        this.process.on('error', e => {
            this.emit('error', e.message);
        });
        this.process.stderr.on('data', chunk => {
            console.error(chunk.toString('utf8')); // tslint:disable-line
        });
        const rl = readline_1.default.createInterface(this.process.stdout);
        rl.on('line', line => {
            if (!line.length)
                return;
            let res = coc_nvim_1.ansiparse(line);
            let idx = res.findIndex(o => o.foreground == 'yellow');
            let message = idx == -1 ? null : res[idx + 1].text;
            let item = res.find(o => o.foreground == 'red' && o.text.length > 4);
            let commit = item ? item.text : '';
            this.emit('data', {
                label: line,
                data: {
                    commit,
                    root: this.root,
                    message: message ? message.trim() : null
                }
            });
        });
        rl.on('close', () => {
            this.emit('end');
        });
    }
    dispose() {
        if (this.process) {
            this.process.kill();
        }
    }
}
class Commits extends coc_nvim_1.BasicList {
    constructor(nvim, manager) {
        super(nvim);
        this.manager = manager;
        this.name = 'commits';
        this.description = 'Commits of current project.';
        this.defaultAction = 'show';
        this.actions = [];
        this.cachedCommits = new Map();
        this.addAction('preview', (item, context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let winid = context.listWindow.id;
            let mod = context.options.position == 'top' ? 'below' : 'above';
            let { commit, root } = item.data;
            if (!commit) {
                yield util_1.showEmptyPreview(mod, winid);
                return;
            }
            let lines = this.cachedCommits.get(commit);
            if (!lines) {
                let content = yield util_1.runCommand(`git --no-pager show ${commit}`, { cwd: root });
                lines = content.replace(/\n$/, '').split(/\r?\n/);
                this.cachedCommits.set(commit, lines);
            }
            nvim.pauseNotification();
            nvim.command('pclose', true);
            nvim.command(`${mod} ${this.previewHeight}sp +setl\\ previewwindow [commit ${commit}]`, true);
            nvim.command('setl winfixheight buftype=nofile foldmethod=syntax foldenable', true);
            nvim.command('setl nobuflisted bufhidden=wipe', true);
            nvim.command('setf git', true);
            nvim.call('append', [0, lines], true);
            nvim.command('normal! Gdd', true);
            nvim.command(`exe 1`, true);
            nvim.call('win_gotoid', [winid], true);
            yield nvim.resumeNotification();
        }));
        this.addAction('show', (item) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { commit, root } = item.data;
            if (!commit)
                return;
            let hasFugitive = yield nvim.getVar('loaded_fugitive');
            if (hasFugitive) {
                yield nvim.command(`Gedit ${commit}`);
            }
            else {
                let lines = this.cachedCommits.get(commit);
                if (!lines) {
                    let content = yield util_1.runCommand(`git --no-pager show ${commit}`, { cwd: root });
                    lines = content.replace(/\n$/, '').split(/\r?\n/);
                    this.cachedCommits.set(commit, lines);
                }
                nvim.pauseNotification();
                nvim.command(`edit +setl\\ buftype=nofile [commit ${commit}]`, true);
                nvim.command('setl foldmethod=syntax nobuflisted bufhidden=wipe', true);
                nvim.command('setf git', true);
                nvim.call('append', [0, lines], true);
                nvim.command('normal! Gdd', true);
                nvim.command(`exe 1`, true);
                yield nvim.resumeNotification();
            }
        }));
        this.addAction('reset', (item) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { root, commit } = item.data;
            if (!commit)
                return;
            let choices = ['&Mixed', '&Soft', '&Hard'];
            let n = yield nvim.call('confirm', [`Choose mode for reset:`, choices.join('\n')]);
            if (!n || n < 1)
                return;
            let opt = '';
            switch (n) {
                case 1:
                    opt = '--mixed';
                    break;
                case 2:
                    opt = '--soft';
                    break;
                case 3:
                    opt = '--hard';
                    break;
            }
            yield util_1.runCommand(`git reset ${opt} ${commit}`, { cwd: root });
        }));
        this.addAction('checkout', (item) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { root, commit } = item.data;
            if (!commit)
                return;
            yield util_1.runCommand(`git checkout ${commit}`, { cwd: root });
        }));
        this.addMultipleAction('revert', (items) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let list = items.filter(item => item.data.commit != null);
            if (!list.length)
                return;
            let arg = list.map(o => o.data.commit).join(' ');
            yield util_1.runCommand(`git revert ${arg}`, { cwd: list[0].data.root });
        }));
        this.addMultipleAction('diff', (items, context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let list = items.filter(item => item.data.commit != null);
            if (!list.length) {
                nvim.command('pclose', true);
                return;
            }
            let arg;
            if (list.length == 1) {
                arg = `${list[0].data.commit} HEAD`;
            }
            else {
                arg = `${list[1].data.commit} ${list[0].data.commit}`;
            }
            let content = yield util_1.runCommand(`git --no-pager diff ${arg}`, { cwd: list[0].data.root });
            let lines = content.replace(/\n$/, '').split('\n');
            let winid = context.listWindow.id;
            let mod = context.options.position == 'top' ? 'below' : 'above';
            nvim.pauseNotification();
            nvim.command('pclose', true);
            nvim.command(`${mod} ${this.previewHeight}sp +setl\\ previewwindow [diff ${arg}]`, true);
            nvim.command('setl winfixheight buftype=nofile foldmethod=syntax foldenable', true);
            nvim.command('setl nobuflisted bufhidden=wipe', true);
            nvim.command('setf git', true);
            nvim.call('append', [0, lines], true);
            nvim.command('normal! Gdd', true);
            nvim.command(`exe 1`, true);
            nvim.call('win_gotoid', [winid], true);
            yield nvim.resumeNotification();
        }), { persist: true, reload: false });
        this.addMultipleAction('copy', (items) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let list = items.filter(item => item.data.message != null);
            let lines = list.map(o => o.data.message);
            yield util_1.runCommandWithData('pbcopy', [], process.cwd(), lines.join('\n'));
        }));
        this.addAction('files', (item) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { commit } = item.data;
            if (!commit)
                return;
            nvim.command(`CocList gfiles ${commit}`, true);
        }));
    }
    loadItems(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let buf = yield context.window.buffer;
            let root = yield this.manager.resolveGitRoot(buf.id);
            if (!root) {
                throw new Error(`Can't resolve git root.`);
                return;
            }
            const args = ['--no-pager', 'log', '--graph', '--pretty', '--color',
                `--format=%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cd) %C(bold blue)<%an>%Creset`,
                '--abbrev-commit', ...context.args];
            let task = new CommitsTask(root);
            task.start('git', args, root);
            return task;
        });
    }
}
exports.default = Commits;
//# sourceMappingURL=commits.js.map